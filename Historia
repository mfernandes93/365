
configurar projeto e instalar bibliotecas 

1Ô∏è‚É£ System.Net.Http (Incluso no .NET Framework 4.5.2)
üìå Por que foi usado?

Permite enviar requisi√ß√µes HTTP √† API usando HttpClient.
Habilita a configura√ß√£o do HttpClientHandler, que permite adicionar o certificado do cliente na requisi√ß√£o.
Fundamental para enviar requisi√ß√µes seguras ao servidor e receber a resposta (incluindo o token).
üîπ O que resolveu?
‚úî Possibilitou a comunica√ß√£o segura com a API via HTTPS.
‚úî Garantiu que o certificado do cliente fosse enviado corretamente na autentica√ß√£o m√∫tua TLS.

2Ô∏è‚É£ System.Security.Cryptography.X509Certificates (Incluso no .NET)
üìå Por que foi usado?

Respons√°vel por carregar e gerenciar o certificado digital do cliente no formato PFX.
Permite a aplica√ß√£o incluir certificados X.509 na requisi√ß√£o, o que √© essencial para a autentica√ß√£o m√∫tua TLS.
üîπ O que resolveu?
‚úî Carregou o certificado necess√°rio para autenticar a aplica√ß√£o junto √† API.
‚úî Garantiu que a comunica√ß√£o fosse segura e confi√°vel.

3Ô∏è‚É£ ServicePointManager (Incluso no .NET)
üìå Por que foi usado?

Configurado para for√ßar o uso de TLS 1.2, garantindo compatibilidade com servidores modernos, j√° que vers√µes antigas do .NET podem usar TLS 1.0 por padr√£o.
Permite a valida√ß√£o do certificado do servidor quando necess√°rio.
üîπ O que resolveu?
‚úî Evitou falhas de conex√£o por protocolos de seguran√ßa desatualizados.
‚úî Garantiu que a aplica√ß√£o usasse um protocolo seguro (TLS 1.2) para se comunicar com a API.
























implemetar autentica√ß√£o

1. Escolha do Modelo TradOps
Por que TradOps?

Esse modelo permite autenticar a aplica√ß√£o diretamente via certificados sem precisar hospedar a aplica√ß√£o dentro da AWS.
Evita a necessidade de configura√ß√µes adicionais na infraestrutura da AWS, tornando a implementa√ß√£o mais simples.
Utiliza Mutual TLS (mTLS) para autentica√ß√£o segura entre a aplica√ß√£o cliente e a API, garantindo que apenas clientes autorizados possam se conectar.
2. Obten√ß√£o dos Certificados
Para configurar Mutual TLS, foi necess√°rio obter tr√™s arquivos de certificados:

certificado.pem ‚Üí Cont√©m o certificado p√∫blico da aplica√ß√£o (usado para autenticar a identidade da aplica√ß√£o cliente).
chave.pem ‚Üí Cont√©m a chave privada, essencial para a assinatura digital da comunica√ß√£o.
ca.pem ‚Üí Certificado da Autoridade Certificadora (CA) respons√°vel por validar a autenticidade do servidor.

3. Convers√£o de PEM para PFX
Por que converter certificado.pem e chave.pem para PFX (.pfx)?

O formato PEM armazena os certificados e a chave privada em arquivos separados, mas o .NET Framework 4.5.2 n√£o suporta diretamente a leitura de arquivos .pem para autentica√ß√£o m√∫tua TLS.
O formato PFX (.pfx) combina o certificado p√∫blico e a chave privada em um √∫nico arquivo, facilitando a manipula√ß√£o no .NET.
O PFX pode ser carregado diretamente no X509Certificate2, permitindo sua utiliza√ß√£o no HttpClientHandler para autentica√ß√£o segura.


4. Como a Convers√£o de PEM para PFX Foi Feita
A convers√£o foi realizada usando OpenSSL, pois o formato PFX (PKCS#12) suporta armazenamento de certificados e chaves privadas juntos.


Comando OpenSSL para a Convers√£o
openssl pkcs12 -export -out client_cert.pfx -inkey chave.pem -in certificado.pem -certfile ca.pem




5. Carregamento do Certificado PFX na Aplica√ß√£o
Ap√≥s a convers√£o, o arquivo client_cert.pfx foi carregado dentro da aplica√ß√£o .NET usando X509Certificate2, para ser enviado nas requisi√ß√µes para a API.

****************************************************************************************
var clientCertificate = new X509Certificate2("client_cert.pfx", "senha_do_certificado");
****************************************************************************************

O que isso faz?
Carrega o certificado combinado (p√∫blico + chave privada) na aplica√ß√£o.
Permite que a requisi√ß√£o seja autenticada corretamente usando Mutual TLS.


6. Configura√ß√£o da Requisi√ß√£o com o Certificado
Para que a aplica√ß√£o pudesse se comunicar com a API, foi configurado um HttpClientHandler que inclu√≠a o certificado PFX:

****************************************************************************************
var handler = new HttpClientHandler();
handler.ClientCertificates.Add(clientCertificate);
****************************************************************************************

Isso garantiu que todas as requisi√ß√µes HTTP enviadas para a API inclu√≠ssem automaticamente o certificado digital, autenticando a aplica√ß√£o sem precisar de credenciais manuais (como client_id e client_secret).

7. Envio da Requisi√ß√£o para Obter o Token
Com o certificado PFX carregado, a aplica√ß√£o enviou uma requisi√ß√£o HTTPS para a API TradOps:

****************************************************************************************
using (var client = new HttpClient(handler))
{
    var response = client.PostAsync("https://vault-tradops.dev.ops.aws.cloud.ihf/v1/auth/cert/login", null).Result;
    string content = response.Content.ReadAsStringAsync().Result;
}
****************************************************************************************

üìå Explica√ß√£o:
A API reconheceu o certificado do cliente e validou a identidade da aplica√ß√£o.
A resposta da API continha o token de acesso, necess√°rio para autenticar chamadas futuras √† Microsoft Graph API.







1. Abertura de Chamado para Obten√ß√£o do Token Inicial
Antes de qualquer configura√ß√£o t√©cnica, foi necess√°rio abrir um chamado para solicitar um token de uso √∫nico.

Por que esse chamado foi necess√°rio?
O sistema TradOps exige um primeiro passo de autentica√ß√£o para liberar o acesso ao Vault TradOps, que armazena os certificados necess√°rios para autentica√ß√£o m√∫tua TLS.
Esse token inicial √© essencial para desbloquear o certificado e a chave privada que seriam utilizados posteriormente na autentica√ß√£o da aplica√ß√£o.

2. Uso do curl no Git Bash para Obter o Token Final
Ap√≥s receber o token de uso √∫nico, foi necess√°rio us√°-lo para desbloquear o token final que permitiria acessar os certificados.

Esse processo foi realizado executando o seguinte comando no Git Bash:

---------- curl -skX POST https://vault-tradops.dev.ops.aws.cloud.ihf/v1/sys/wrapping/unwrap ---------

Resultado: Esse comando retornou um token em texto, que seria utilizado para recuperar os arquivos de certificado.

3. Convers√£o do Certificado para o Formato .pem
Com o token final em m√£os, foi poss√≠vel acessar os arquivos do certificado no Vault TradOps, obtendo tr√™s arquivos no formato PEM:

certificado.pem ‚Üí Certificado p√∫blico do cliente.
chave.pem ‚Üí Chave privada associada ao certificado.
ca.pem ‚Üí Certificado da Autoridade Certificadora (CA).
Esses arquivos s√£o necess√°rios para a autentica√ß√£o m√∫tua TLS, mas, no .NET Framework 4.5.2, n√£o √© poss√≠vel utilizar arquivos PEM diretamente.

Por isso, foi necess√°rio converter o certificado e a chave privada para o formato PFX.

4. Convers√£o de PEM para PFX
A convers√£o foi feita usando OpenSSL, pois o formato PFX (PKCS#12) suporta o armazenamento do certificado e da chave privada em um √∫nico arquivo.

Comando para Converter PEM ‚Üí PFX

------------- openssl pkcs12 -export -out client_cert.pfx -inkey chave.pem -in certificado.pem -certfile ca.pem  ------------

Resultado: Agora a aplica√ß√£o possui o arquivo client_cert.pfx, que pode ser carregado diretamente no .NET para realizar a autentica√ß√£o.

5. Carregamento do Certificado na Aplica√ß√£o
Com o arquivo PFX pronto, o pr√≥ximo passo foi carregar o certificado dentro da aplica√ß√£o.

---------- var clientCertificate = new X509Certificate2("client_cert.pfx", "senha_do_certificado"); -------------

Carrega o certificado PFX na aplica√ß√£o, garantindo que o cliente possa se autenticar na API TradOps.

6. Configura√ß√£o do HttpClientHandler para Autentica√ß√£o M√∫tua TLS
Para que o certificado fosse enviado automaticamente nas requisi√ß√µes para a API TradOps, foi configurado um HttpClientHandler:
------------
var handler = new HttpClientHandler();
handler.ClientCertificates.Add(clientCertificate);
------------
Isso garantiu que o certificado fosse inclu√≠do automaticamente nas requisi√ß√µes para autentica√ß√£o.

7. Envio da Requisi√ß√£o para Obter o Token
Com o certificado PFX carregado e o HttpClientHandler configurado, foi poss√≠vel enviar uma requisi√ß√£o para a API TradOps e obter o token final de autentica√ß√£o:
-------------------------
using (var client = new HttpClient(handler))
{
    var response = client.PostAsync("https://vault-tradops.dev.ops.aws.cloud.ihf/v1/auth/cert/login", null).Result;
    string content = response.Content.ReadAsStringAsync().Result;
   
}
------------------------
O servidor reconheceu o certificado do cliente e retornou o token de acesso, que pode ser usado para acessar a Microsoft Graph API e outras integra√ß√µes.


















